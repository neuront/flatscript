#include <util/string.h>
#include <globals.h>

#include "global.h"

using namespace output;
using flats::Globals;

static std::string export_point_for_browser()
{
    if (Globals::g.export_point.empty()) {
        return "window";
    }
    return util::replace_all("(window.#EP = window.#EP || {})", "#EP", Globals::g.export_point);
}

void output::wrapGlobal(std::ostream& os, util::sref<Statement const> global)
{
    os << "/* Generated by Flatscript:" + Globals::version + " */" << std::endl;
    std::vector<std::string> parameters;
    std::vector<std::string> arguments;
    if (Globals::g.use_export) {
        parameters.push_back("$export");
        arguments.push_back(
            "typeof module !== 'undefined' && typeof module.exports !== 'undefined'"
            " ? module.exports : " + export_point_for_browser());
    }
    os << "(function(" << util::join(",", parameters) << ") {" << std::endl;
    if (Globals::g.use_class_ext) {
        os <<
            "function $extend(i, b) {"
                "var base = b.$class;"
                "for (var k in base) {"
                    "if (base.hasOwnProperty(k)) {"
                        "i[k] = base[k]"
                    "}"
                "}"
                "function ctor() {"
                    "this.constructor = i"
                "}"
                "ctor.prototype = base.prototype;"
                "i.prototype = new ctor();"
                "i.$super = base.prototype;"
                "return i"
            "}";
    }
    if (Globals::g.use_list_slice) {
        os <<
            "function $listslice($list, $begin, $end, $step) {"
                "function $rnd(x, dft) {"
                    "if (typeof x === 'undefined') return dft;"
                    "if (x > $list.length) return $list.length;"
                    "if (x < 0) return x % $list.length + $list.length;"
                    "return x"
                "}"
                "if (!$step || $step == 1) {"
                    "return $list.slice($begin, $end)"
                "}"
                "var r = [];"
                "if ($step > 0) {"
                    "$begin = $rnd($begin, 0);"
                    "$end = $rnd($end, $list.length);"
                    "for (; $begin < $end; $begin += $step) {"
                        "r.push($list[$begin]);"
                    "}"
                "} else {"
                    "$begin = $rnd($begin, $list.length - 1);"
                    "$end = $rnd($end, -1);"
                    "for (; $begin > $end; $begin += $step) {"
                        "r.push($list[$begin]);"
                    "}"
                "}"
                "return typeof $list === 'string' ? r.join('') : r"
            "}";
    }
    if (Globals::g.use_list_pipe) {
        os <<
            "function $listpipe($list, $next) {"
                "if (!($list)) return;"
                "var $result = [];"
                "var $ind = 0;"
                "for (var $k in $list) {"
                    "if ($list.hasOwnProperty($k)) {"
                        "$next($ind, $k, $list[$k], $result);"
                        "++$ind;"
                    "}"
                "}"
                "return $result;"
            "}";
    }
    global->write(os);
    os << "})(" << util::join(",", arguments) << ");" << std::endl;
}
